// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: hservices.queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAllHServices = `-- name: CountAllHServices :one
SELECT COUNT(*) FROM hservices
`

func (q *Queries) CountAllHServices(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAllHServices)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countHServicesByUsername = `-- name: CountHServicesByUsername :one
SELECT COUNT(*) FROM hservices
WHERE user_id = (SELECT id FROM users WHERE users.username = $1 LIMIT 1)
`

func (q *Queries) CountHServicesByUsername(ctx context.Context, username string) (int64, error) {
	row := q.db.QueryRow(ctx, countHServicesByUsername, username)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMyHServices = `-- name: CountMyHServices :one
SELECT COUNT(*) FROM hservices
WHERE user_id = $1
`

func (q *Queries) CountMyHServices(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRow(ctx, countMyHServices, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createHService = `-- name: CreateHService :one
INSERT INTO hservices (
  id,
  user_id,
  title,
  slug,
  description,
  category,
  price,
  price_unit,
  price_timespan,
  is_online,
  url,
  location,
  delivery_time,
  delivery_timespan,
  total_points,
  total_votes,
  media,
  created_at,
  updated_at
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10,
  $11,
  $12,
  $13,
  $14,
  $15,
  $16,
  $17,
  $18,
  $19
)
RETURNING id, user_id, title, slug, description, category, price, price_unit, price_timespan, is_online, url, location, delivery_time, delivery_timespan, total_points, total_votes, media, created_at, updated_at
`

type CreateHServiceParams struct {
	ID               string
	UserID           string
	Title            string
	Slug             string
	Description      string
	Category         int32
	Price            float64
	PriceUnit        Priceunit
	PriceTimespan    Worktimespan
	IsOnline         bool
	Url              pgtype.Text
	Location         string
	DeliveryTime     int32
	DeliveryTimespan Worktimespan
	TotalPoints      int64
	TotalVotes       int32
	Media            []byte
	CreatedAt        pgtype.Timestamptz
	UpdatedAt        pgtype.Timestamptz
}

func (q *Queries) CreateHService(ctx context.Context, arg CreateHServiceParams) (Hservice, error) {
	row := q.db.QueryRow(ctx, createHService,
		arg.ID,
		arg.UserID,
		arg.Title,
		arg.Slug,
		arg.Description,
		arg.Category,
		arg.Price,
		arg.PriceUnit,
		arg.PriceTimespan,
		arg.IsOnline,
		arg.Url,
		arg.Location,
		arg.DeliveryTime,
		arg.DeliveryTimespan,
		arg.TotalPoints,
		arg.TotalVotes,
		arg.Media,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Hservice
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.Category,
		&i.Price,
		&i.PriceUnit,
		&i.PriceTimespan,
		&i.IsOnline,
		&i.Url,
		&i.Location,
		&i.DeliveryTime,
		&i.DeliveryTimespan,
		&i.TotalPoints,
		&i.TotalVotes,
		&i.Media,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFavoriteHServices = `-- name: GetFavoriteHServices :many
SELECT hservices.id, hservices.user_id, hservices.title, hservices.slug, hservices.description, hservices.category, hservices.price, hservices.price_unit, hservices.price_timespan, hservices.is_online, hservices.url, hservices.location, hservices.delivery_time, hservices.delivery_timespan, hservices.total_points, hservices.total_votes, hservices.media, hservices.created_at, hservices.updated_at, users.id, users.email, users.username, users.full_name, users.password_hash, users.google_id, users.is_email_verified, users.is_active, users.role, users.password_reset_token, users.password_reset_expires, users.login_attempts, users.lockout_until, users.gender, users.profile_image, users.last_login, users.created_at, users.updated_at FROM hservices
JOIN users ON users.id = hservices.user_id
ORDER BY total_points DESC -- TODO: Replace with total_favorites later
LIMIT 25
`

type GetFavoriteHServicesRow struct {
	Hservice Hservice
	User     User
}

func (q *Queries) GetFavoriteHServices(ctx context.Context) ([]GetFavoriteHServicesRow, error) {
	rows, err := q.db.Query(ctx, getFavoriteHServices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFavoriteHServicesRow
	for rows.Next() {
		var i GetFavoriteHServicesRow
		if err := rows.Scan(
			&i.Hservice.ID,
			&i.Hservice.UserID,
			&i.Hservice.Title,
			&i.Hservice.Slug,
			&i.Hservice.Description,
			&i.Hservice.Category,
			&i.Hservice.Price,
			&i.Hservice.PriceUnit,
			&i.Hservice.PriceTimespan,
			&i.Hservice.IsOnline,
			&i.Hservice.Url,
			&i.Hservice.Location,
			&i.Hservice.DeliveryTime,
			&i.Hservice.DeliveryTimespan,
			&i.Hservice.TotalPoints,
			&i.Hservice.TotalVotes,
			&i.Hservice.Media,
			&i.Hservice.CreatedAt,
			&i.Hservice.UpdatedAt,
			&i.User.ID,
			&i.User.Email,
			&i.User.Username,
			&i.User.FullName,
			&i.User.PasswordHash,
			&i.User.GoogleID,
			&i.User.IsEmailVerified,
			&i.User.IsActive,
			&i.User.Role,
			&i.User.PasswordResetToken,
			&i.User.PasswordResetExpires,
			&i.User.LoginAttempts,
			&i.User.LockoutUntil,
			&i.User.Gender,
			&i.User.ProfileImage,
			&i.User.LastLogin,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFeaturedHServices = `-- name: GetFeaturedHServices :many
SELECT hservices.id, hservices.user_id, hservices.title, hservices.slug, hservices.description, hservices.category, hservices.price, hservices.price_unit, hservices.price_timespan, hservices.is_online, hservices.url, hservices.location, hservices.delivery_time, hservices.delivery_timespan, hservices.total_points, hservices.total_votes, hservices.media, hservices.created_at, hservices.updated_at, users.id, users.email, users.username, users.full_name, users.password_hash, users.google_id, users.is_email_verified, users.is_active, users.role, users.password_reset_token, users.password_reset_expires, users.login_attempts, users.lockout_until, users.gender, users.profile_image, users.last_login, users.created_at, users.updated_at FROM hservices
JOIN users ON users.id = hservices.user_id
WHERE total_votes != 0
ORDER BY total_points / total_votes DESC, total_votes DESC
LIMIT 25
`

type GetFeaturedHServicesRow struct {
	Hservice Hservice
	User     User
}

func (q *Queries) GetFeaturedHServices(ctx context.Context) ([]GetFeaturedHServicesRow, error) {
	rows, err := q.db.Query(ctx, getFeaturedHServices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFeaturedHServicesRow
	for rows.Next() {
		var i GetFeaturedHServicesRow
		if err := rows.Scan(
			&i.Hservice.ID,
			&i.Hservice.UserID,
			&i.Hservice.Title,
			&i.Hservice.Slug,
			&i.Hservice.Description,
			&i.Hservice.Category,
			&i.Hservice.Price,
			&i.Hservice.PriceUnit,
			&i.Hservice.PriceTimespan,
			&i.Hservice.IsOnline,
			&i.Hservice.Url,
			&i.Hservice.Location,
			&i.Hservice.DeliveryTime,
			&i.Hservice.DeliveryTimespan,
			&i.Hservice.TotalPoints,
			&i.Hservice.TotalVotes,
			&i.Hservice.Media,
			&i.Hservice.CreatedAt,
			&i.Hservice.UpdatedAt,
			&i.User.ID,
			&i.User.Email,
			&i.User.Username,
			&i.User.FullName,
			&i.User.PasswordHash,
			&i.User.GoogleID,
			&i.User.IsEmailVerified,
			&i.User.IsActive,
			&i.User.Role,
			&i.User.PasswordResetToken,
			&i.User.PasswordResetExpires,
			&i.User.LoginAttempts,
			&i.User.LockoutUntil,
			&i.User.Gender,
			&i.User.ProfileImage,
			&i.User.LastLogin,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHServiceById = `-- name: GetHServiceById :one
SELECT hservices.id, hservices.user_id, hservices.title, hservices.slug, hservices.description, hservices.category, hservices.price, hservices.price_unit, hservices.price_timespan, hservices.is_online, hservices.url, hservices.location, hservices.delivery_time, hservices.delivery_timespan, hservices.total_points, hservices.total_votes, hservices.media, hservices.created_at, hservices.updated_at, users.id, users.email, users.username, users.full_name, users.password_hash, users.google_id, users.is_email_verified, users.is_active, users.role, users.password_reset_token, users.password_reset_expires, users.login_attempts, users.lockout_until, users.gender, users.profile_image, users.last_login, users.created_at, users.updated_at FROM hservices
JOIN users ON users.id = hservices.user_id
WHERE hservices.id = $1
LIMIT 1
`

type GetHServiceByIdRow struct {
	Hservice Hservice
	User     User
}

func (q *Queries) GetHServiceById(ctx context.Context, id string) (GetHServiceByIdRow, error) {
	row := q.db.QueryRow(ctx, getHServiceById, id)
	var i GetHServiceByIdRow
	err := row.Scan(
		&i.Hservice.ID,
		&i.Hservice.UserID,
		&i.Hservice.Title,
		&i.Hservice.Slug,
		&i.Hservice.Description,
		&i.Hservice.Category,
		&i.Hservice.Price,
		&i.Hservice.PriceUnit,
		&i.Hservice.PriceTimespan,
		&i.Hservice.IsOnline,
		&i.Hservice.Url,
		&i.Hservice.Location,
		&i.Hservice.DeliveryTime,
		&i.Hservice.DeliveryTimespan,
		&i.Hservice.TotalPoints,
		&i.Hservice.TotalVotes,
		&i.Hservice.Media,
		&i.Hservice.CreatedAt,
		&i.Hservice.UpdatedAt,
		&i.User.ID,
		&i.User.Email,
		&i.User.Username,
		&i.User.FullName,
		&i.User.PasswordHash,
		&i.User.GoogleID,
		&i.User.IsEmailVerified,
		&i.User.IsActive,
		&i.User.Role,
		&i.User.PasswordResetToken,
		&i.User.PasswordResetExpires,
		&i.User.LoginAttempts,
		&i.User.LockoutUntil,
		&i.User.Gender,
		&i.User.ProfileImage,
		&i.User.LastLogin,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
	)
	return i, err
}

const getHServicesByUsername = `-- name: GetHServicesByUsername :many
SELECT hservices.id, hservices.user_id, hservices.title, hservices.slug, hservices.description, hservices.category, hservices.price, hservices.price_unit, hservices.price_timespan, hservices.is_online, hservices.url, hservices.location, hservices.delivery_time, hservices.delivery_timespan, hservices.total_points, hservices.total_votes, hservices.media, hservices.created_at, hservices.updated_at, users.id, users.email, users.username, users.full_name, users.password_hash, users.google_id, users.is_email_verified, users.is_active, users.role, users.password_reset_token, users.password_reset_expires, users.login_attempts, users.lockout_until, users.gender, users.profile_image, users.last_login, users.created_at, users.updated_at FROM hservices
JOIN users ON users.id = hservices.user_id
WHERE hservices.user_id = (SELECT id FROM users WHERE users.username = $1 LIMIT 1)
ORDER BY hservices.created_at DESC
OFFSET $2
LIMIT $3
`

type GetHServicesByUsernameParams struct {
	Username string
	Offset   int32
	Limit    int32
}

type GetHServicesByUsernameRow struct {
	Hservice Hservice
	User     User
}

func (q *Queries) GetHServicesByUsername(ctx context.Context, arg GetHServicesByUsernameParams) ([]GetHServicesByUsernameRow, error) {
	rows, err := q.db.Query(ctx, getHServicesByUsername, arg.Username, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHServicesByUsernameRow
	for rows.Next() {
		var i GetHServicesByUsernameRow
		if err := rows.Scan(
			&i.Hservice.ID,
			&i.Hservice.UserID,
			&i.Hservice.Title,
			&i.Hservice.Slug,
			&i.Hservice.Description,
			&i.Hservice.Category,
			&i.Hservice.Price,
			&i.Hservice.PriceUnit,
			&i.Hservice.PriceTimespan,
			&i.Hservice.IsOnline,
			&i.Hservice.Url,
			&i.Hservice.Location,
			&i.Hservice.DeliveryTime,
			&i.Hservice.DeliveryTimespan,
			&i.Hservice.TotalPoints,
			&i.Hservice.TotalVotes,
			&i.Hservice.Media,
			&i.Hservice.CreatedAt,
			&i.Hservice.UpdatedAt,
			&i.User.ID,
			&i.User.Email,
			&i.User.Username,
			&i.User.FullName,
			&i.User.PasswordHash,
			&i.User.GoogleID,
			&i.User.IsEmailVerified,
			&i.User.IsActive,
			&i.User.Role,
			&i.User.PasswordResetToken,
			&i.User.PasswordResetExpires,
			&i.User.LoginAttempts,
			&i.User.LockoutUntil,
			&i.User.Gender,
			&i.User.ProfileImage,
			&i.User.LastLogin,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMyHServices = `-- name: GetMyHServices :many
SELECT id, user_id, title, slug, description, category, price, price_unit, price_timespan, is_online, url, location, delivery_time, delivery_timespan, total_points, total_votes, media, created_at, updated_at FROM hservices
WHERE user_id = $1
ORDER BY created_at DESC
OFFSET $2
LIMIT $3
`

type GetMyHServicesParams struct {
	UserID string
	Offset int32
	Limit  int32
}

func (q *Queries) GetMyHServices(ctx context.Context, arg GetMyHServicesParams) ([]Hservice, error) {
	rows, err := q.db.Query(ctx, getMyHServices, arg.UserID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Hservice
	for rows.Next() {
		var i Hservice
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.Category,
			&i.Price,
			&i.PriceUnit,
			&i.PriceTimespan,
			&i.IsOnline,
			&i.Url,
			&i.Location,
			&i.DeliveryTime,
			&i.DeliveryTimespan,
			&i.TotalPoints,
			&i.TotalVotes,
			&i.Media,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNewHServices = `-- name: GetNewHServices :many
SELECT hservices.id, hservices.user_id, hservices.title, hservices.slug, hservices.description, hservices.category, hservices.price, hservices.price_unit, hservices.price_timespan, hservices.is_online, hservices.url, hservices.location, hservices.delivery_time, hservices.delivery_timespan, hservices.total_points, hservices.total_votes, hservices.media, hservices.created_at, hservices.updated_at, users.id, users.email, users.username, users.full_name, users.password_hash, users.google_id, users.is_email_verified, users.is_active, users.role, users.password_reset_token, users.password_reset_expires, users.login_attempts, users.lockout_until, users.gender, users.profile_image, users.last_login, users.created_at, users.updated_at FROM hservices
JOIN users ON users.id = hservices.user_id
ORDER BY hservices.created_at DESC
LIMIT 25
`

type GetNewHServicesRow struct {
	Hservice Hservice
	User     User
}

func (q *Queries) GetNewHServices(ctx context.Context) ([]GetNewHServicesRow, error) {
	rows, err := q.db.Query(ctx, getNewHServices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNewHServicesRow
	for rows.Next() {
		var i GetNewHServicesRow
		if err := rows.Scan(
			&i.Hservice.ID,
			&i.Hservice.UserID,
			&i.Hservice.Title,
			&i.Hservice.Slug,
			&i.Hservice.Description,
			&i.Hservice.Category,
			&i.Hservice.Price,
			&i.Hservice.PriceUnit,
			&i.Hservice.PriceTimespan,
			&i.Hservice.IsOnline,
			&i.Hservice.Url,
			&i.Hservice.Location,
			&i.Hservice.DeliveryTime,
			&i.Hservice.DeliveryTimespan,
			&i.Hservice.TotalPoints,
			&i.Hservice.TotalVotes,
			&i.Hservice.Media,
			&i.Hservice.CreatedAt,
			&i.Hservice.UpdatedAt,
			&i.User.ID,
			&i.User.Email,
			&i.User.Username,
			&i.User.FullName,
			&i.User.PasswordHash,
			&i.User.GoogleID,
			&i.User.IsEmailVerified,
			&i.User.IsActive,
			&i.User.Role,
			&i.User.PasswordResetToken,
			&i.User.PasswordResetExpires,
			&i.User.LoginAttempts,
			&i.User.LockoutUntil,
			&i.User.Gender,
			&i.User.ProfileImage,
			&i.User.LastLogin,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPopularHServices = `-- name: GetPopularHServices :many
SELECT hservices.id, hservices.user_id, hservices.title, hservices.slug, hservices.description, hservices.category, hservices.price, hservices.price_unit, hservices.price_timespan, hservices.is_online, hservices.url, hservices.location, hservices.delivery_time, hservices.delivery_timespan, hservices.total_points, hservices.total_votes, hservices.media, hservices.created_at, hservices.updated_at, users.id, users.email, users.username, users.full_name, users.password_hash, users.google_id, users.is_email_verified, users.is_active, users.role, users.password_reset_token, users.password_reset_expires, users.login_attempts, users.lockout_until, users.gender, users.profile_image, users.last_login, users.created_at, users.updated_at FROM hservices
JOIN users ON users.id = hservices.user_id
ORDER BY total_votes DESC
LIMIT 25
`

type GetPopularHServicesRow struct {
	Hservice Hservice
	User     User
}

func (q *Queries) GetPopularHServices(ctx context.Context) ([]GetPopularHServicesRow, error) {
	rows, err := q.db.Query(ctx, getPopularHServices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPopularHServicesRow
	for rows.Next() {
		var i GetPopularHServicesRow
		if err := rows.Scan(
			&i.Hservice.ID,
			&i.Hservice.UserID,
			&i.Hservice.Title,
			&i.Hservice.Slug,
			&i.Hservice.Description,
			&i.Hservice.Category,
			&i.Hservice.Price,
			&i.Hservice.PriceUnit,
			&i.Hservice.PriceTimespan,
			&i.Hservice.IsOnline,
			&i.Hservice.Url,
			&i.Hservice.Location,
			&i.Hservice.DeliveryTime,
			&i.Hservice.DeliveryTimespan,
			&i.Hservice.TotalPoints,
			&i.Hservice.TotalVotes,
			&i.Hservice.Media,
			&i.Hservice.CreatedAt,
			&i.Hservice.UpdatedAt,
			&i.User.ID,
			&i.User.Email,
			&i.User.Username,
			&i.User.FullName,
			&i.User.PasswordHash,
			&i.User.GoogleID,
			&i.User.IsEmailVerified,
			&i.User.IsActive,
			&i.User.Role,
			&i.User.PasswordResetToken,
			&i.User.PasswordResetExpires,
			&i.User.LoginAttempts,
			&i.User.LockoutUntil,
			&i.User.Gender,
			&i.User.ProfileImage,
			&i.User.LastLogin,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRandomHServices = `-- name: GetRandomHServices :many
SELECT id FROM hservices
ORDER BY RANDOM()
LIMIT $1
`

func (q *Queries) GetRandomHServices(ctx context.Context, limit int32) ([]string, error) {
	rows, err := q.db.Query(ctx, getRandomHServices, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listHServices = `-- name: ListHServices :many
SELECT hservices.id, hservices.user_id, hservices.title, hservices.slug, hservices.description, hservices.category, hservices.price, hservices.price_unit, hservices.price_timespan, hservices.is_online, hservices.url, hservices.location, hservices.delivery_time, hservices.delivery_timespan, hservices.total_points, hservices.total_votes, hservices.media, hservices.created_at, hservices.updated_at, users.id, users.email, users.username, users.full_name, users.password_hash, users.google_id, users.is_email_verified, users.is_active, users.role, users.password_reset_token, users.password_reset_expires, users.login_attempts, users.lockout_until, users.gender, users.profile_image, users.last_login, users.created_at, users.updated_at FROM hservices
JOIN users ON users.id = hservices.user_id
ORDER BY hservices.created_at ASC
OFFSET $1
LIMIT $2
`

type ListHServicesParams struct {
	Offset int32
	Limit  int32
}

type ListHServicesRow struct {
	Hservice Hservice
	User     User
}

func (q *Queries) ListHServices(ctx context.Context, arg ListHServicesParams) ([]ListHServicesRow, error) {
	rows, err := q.db.Query(ctx, listHServices, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListHServicesRow
	for rows.Next() {
		var i ListHServicesRow
		if err := rows.Scan(
			&i.Hservice.ID,
			&i.Hservice.UserID,
			&i.Hservice.Title,
			&i.Hservice.Slug,
			&i.Hservice.Description,
			&i.Hservice.Category,
			&i.Hservice.Price,
			&i.Hservice.PriceUnit,
			&i.Hservice.PriceTimespan,
			&i.Hservice.IsOnline,
			&i.Hservice.Url,
			&i.Hservice.Location,
			&i.Hservice.DeliveryTime,
			&i.Hservice.DeliveryTimespan,
			&i.Hservice.TotalPoints,
			&i.Hservice.TotalVotes,
			&i.Hservice.Media,
			&i.Hservice.CreatedAt,
			&i.Hservice.UpdatedAt,
			&i.User.ID,
			&i.User.Email,
			&i.User.Username,
			&i.User.FullName,
			&i.User.PasswordHash,
			&i.User.GoogleID,
			&i.User.IsEmailVerified,
			&i.User.IsActive,
			&i.User.Role,
			&i.User.PasswordResetToken,
			&i.User.PasswordResetExpires,
			&i.User.LoginAttempts,
			&i.User.LockoutUntil,
			&i.User.Gender,
			&i.User.ProfileImage,
			&i.User.LastLogin,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
