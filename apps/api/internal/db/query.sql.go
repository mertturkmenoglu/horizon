// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAllHServices = `-- name: CountAllHServices :one
SELECT COUNT(*) FROM hservices
`

func (q *Queries) CountAllHServices(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAllHServices)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMyHServices = `-- name: CountMyHServices :one
SELECT COUNT(*) FROM hservices
WHERE user_id = $1
`

func (q *Queries) CountMyHServices(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRow(ctx, countMyHServices, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserBookmarks = `-- name: CountUserBookmarks :one
SELECT COUNT(*) FROM bookmarks
WHERE user_id = $1
`

func (q *Queries) CountUserBookmarks(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRow(ctx, countUserBookmarks, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserFavorites = `-- name: CountUserFavorites :one
SELECT COUNT(*) FROM favorites
WHERE user_id = $1
`

func (q *Queries) CountUserFavorites(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRow(ctx, countUserFavorites, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBookmark = `-- name: CreateBookmark :one
INSERT INTO bookmarks (
  user_id,
  hservice_id
) VALUES (
  $1,
  $2
)
RETURNING id, user_id, hservice_id, created_at
`

type CreateBookmarkParams struct {
	UserID     string
	HserviceID string
}

func (q *Queries) CreateBookmark(ctx context.Context, arg CreateBookmarkParams) (Bookmark, error) {
	row := q.db.QueryRow(ctx, createBookmark, arg.UserID, arg.HserviceID)
	var i Bookmark
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.HserviceID,
		&i.CreatedAt,
	)
	return i, err
}

const createCountry = `-- name: CreateCountry :one
INSERT INTO countries (
  id,
  name,
  iso2,
  numeric_code,
  phone_code,
  capital,
  currency,
  currency_name,
  currency_symbol,
  tld,
  native,
  region,
  subregion,
  timezones,
  latitude,
  longitude
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10,
  $11,
  $12,
  $13,
  $14,
  $15,
  $16
)
RETURNING id, name, iso2, numeric_code, phone_code, capital, currency, currency_name, currency_symbol, tld, native, region, subregion, timezones, latitude, longitude
`

type CreateCountryParams struct {
	ID             int32
	Name           string
	Iso2           string
	NumericCode    string
	PhoneCode      string
	Capital        string
	Currency       string
	CurrencyName   string
	CurrencySymbol string
	Tld            string
	Native         string
	Region         string
	Subregion      string
	Timezones      string
	Latitude       float64
	Longitude      float64
}

func (q *Queries) CreateCountry(ctx context.Context, arg CreateCountryParams) (Country, error) {
	row := q.db.QueryRow(ctx, createCountry,
		arg.ID,
		arg.Name,
		arg.Iso2,
		arg.NumericCode,
		arg.PhoneCode,
		arg.Capital,
		arg.Currency,
		arg.CurrencyName,
		arg.CurrencySymbol,
		arg.Tld,
		arg.Native,
		arg.Region,
		arg.Subregion,
		arg.Timezones,
		arg.Latitude,
		arg.Longitude,
	)
	var i Country
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Iso2,
		&i.NumericCode,
		&i.PhoneCode,
		&i.Capital,
		&i.Currency,
		&i.CurrencyName,
		&i.CurrencySymbol,
		&i.Tld,
		&i.Native,
		&i.Region,
		&i.Subregion,
		&i.Timezones,
		&i.Latitude,
		&i.Longitude,
	)
	return i, err
}

const createFavorite = `-- name: CreateFavorite :one
INSERT INTO favorites (
  user_id,
  hservice_id
) VALUES (
  $1,
  $2
)
RETURNING id, user_id, hservice_id, created_at
`

type CreateFavoriteParams struct {
	UserID     string
	HserviceID string
}

func (q *Queries) CreateFavorite(ctx context.Context, arg CreateFavoriteParams) (Favorite, error) {
	row := q.db.QueryRow(ctx, createFavorite, arg.UserID, arg.HserviceID)
	var i Favorite
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.HserviceID,
		&i.CreatedAt,
	)
	return i, err
}

const createHService = `-- name: CreateHService :one
INSERT INTO hservices (
  id,
  user_id,
  title,
  slug,
  description,
  category,
  price,
  price_unit,
  price_timespan,
  is_online,
  url,
  location,
  delivery_time,
  delivery_timespan,
  total_points,
  total_votes,
  media,
  created_at,
  updated_at
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10,
  $11,
  $12,
  $13,
  $14,
  $15,
  $16,
  $17,
  $18,
  $19
)
RETURNING id, user_id, title, slug, description, category, price, price_unit, price_timespan, is_online, url, location, delivery_time, delivery_timespan, total_points, total_votes, media, created_at, updated_at
`

type CreateHServiceParams struct {
	ID               string
	UserID           string
	Title            string
	Slug             string
	Description      string
	Category         int32
	Price            float64
	PriceUnit        Priceunit
	PriceTimespan    Worktimespan
	IsOnline         bool
	Url              pgtype.Text
	Location         string
	DeliveryTime     int32
	DeliveryTimespan Worktimespan
	TotalPoints      int64
	TotalVotes       int32
	Media            []byte
	CreatedAt        pgtype.Timestamptz
	UpdatedAt        pgtype.Timestamptz
}

func (q *Queries) CreateHService(ctx context.Context, arg CreateHServiceParams) (Hservice, error) {
	row := q.db.QueryRow(ctx, createHService,
		arg.ID,
		arg.UserID,
		arg.Title,
		arg.Slug,
		arg.Description,
		arg.Category,
		arg.Price,
		arg.PriceUnit,
		arg.PriceTimespan,
		arg.IsOnline,
		arg.Url,
		arg.Location,
		arg.DeliveryTime,
		arg.DeliveryTimespan,
		arg.TotalPoints,
		arg.TotalVotes,
		arg.Media,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Hservice
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.Category,
		&i.Price,
		&i.PriceUnit,
		&i.PriceTimespan,
		&i.IsOnline,
		&i.Url,
		&i.Location,
		&i.DeliveryTime,
		&i.DeliveryTimespan,
		&i.TotalPoints,
		&i.TotalVotes,
		&i.Media,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createState = `-- name: CreateState :one
INSERT INTO states (
  id,
  name,
  country_id,
  country_code,
  country_name,
  state_code,
  type,
  latitude,
  longitude
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9
)
RETURNING id, name, country_id, country_code, country_name, state_code, type, latitude, longitude
`

type CreateStateParams struct {
	ID          int32
	Name        string
	CountryID   int32
	CountryCode string
	CountryName string
	StateCode   string
	Type        pgtype.Text
	Latitude    float64
	Longitude   float64
}

func (q *Queries) CreateState(ctx context.Context, arg CreateStateParams) (State, error) {
	row := q.db.QueryRow(ctx, createState,
		arg.ID,
		arg.Name,
		arg.CountryID,
		arg.CountryCode,
		arg.CountryName,
		arg.StateCode,
		arg.Type,
		arg.Latitude,
		arg.Longitude,
	)
	var i State
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CountryID,
		&i.CountryCode,
		&i.CountryName,
		&i.StateCode,
		&i.Type,
		&i.Latitude,
		&i.Longitude,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
  id,
  email,
  username,
  full_name,
  password_hash,
  google_id,
  is_email_verified,
  profile_image
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8
)
RETURNING id, email, username, full_name, password_hash, google_id, is_email_verified, is_active, role, password_reset_token, password_reset_expires, login_attempts, lockout_until, gender, profile_image, last_login, created_at, updated_at
`

type CreateUserParams struct {
	ID              string
	Email           string
	Username        string
	FullName        string
	PasswordHash    pgtype.Text
	GoogleID        pgtype.Text
	IsEmailVerified bool
	ProfileImage    pgtype.Text
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.ID,
		arg.Email,
		arg.Username,
		arg.FullName,
		arg.PasswordHash,
		arg.GoogleID,
		arg.IsEmailVerified,
		arg.ProfileImage,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.FullName,
		&i.PasswordHash,
		&i.GoogleID,
		&i.IsEmailVerified,
		&i.IsActive,
		&i.Role,
		&i.PasswordResetToken,
		&i.PasswordResetExpires,
		&i.LoginAttempts,
		&i.LockoutUntil,
		&i.Gender,
		&i.ProfileImage,
		&i.LastLogin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteBookmarkById = `-- name: DeleteBookmarkById :exec
DELETE FROM bookmarks
WHERE id = $1 AND user_id = $2
`

type DeleteBookmarkByIdParams struct {
	ID     pgtype.UUID
	UserID string
}

func (q *Queries) DeleteBookmarkById(ctx context.Context, arg DeleteBookmarkByIdParams) error {
	_, err := q.db.Exec(ctx, deleteBookmarkById, arg.ID, arg.UserID)
	return err
}

const deleteFavoriteById = `-- name: DeleteFavoriteById :exec
DELETE FROM favorites
WHERE id = $1 AND user_id = $2
`

type DeleteFavoriteByIdParams struct {
	ID     pgtype.UUID
	UserID string
}

func (q *Queries) DeleteFavoriteById(ctx context.Context, arg DeleteFavoriteByIdParams) error {
	_, err := q.db.Exec(ctx, deleteFavoriteById, arg.ID, arg.UserID)
	return err
}

const getBookmarkById = `-- name: GetBookmarkById :one
SELECT bookmarks.id, bookmarks.user_id, bookmarks.hservice_id, bookmarks.created_at, hservices.id, hservices.user_id, hservices.title, hservices.slug, hservices.description, hservices.category, hservices.price, hservices.price_unit, hservices.price_timespan, hservices.is_online, hservices.url, hservices.location, hservices.delivery_time, hservices.delivery_timespan, hservices.total_points, hservices.total_votes, hservices.media, hservices.created_at, hservices.updated_at FROM bookmarks
JOIN hservices ON hservices.id = bookmarks.hservice_id
WHERE bookmarks.id = $1
`

type GetBookmarkByIdRow struct {
	Bookmark Bookmark
	Hservice Hservice
}

func (q *Queries) GetBookmarkById(ctx context.Context, id pgtype.UUID) (GetBookmarkByIdRow, error) {
	row := q.db.QueryRow(ctx, getBookmarkById, id)
	var i GetBookmarkByIdRow
	err := row.Scan(
		&i.Bookmark.ID,
		&i.Bookmark.UserID,
		&i.Bookmark.HserviceID,
		&i.Bookmark.CreatedAt,
		&i.Hservice.ID,
		&i.Hservice.UserID,
		&i.Hservice.Title,
		&i.Hservice.Slug,
		&i.Hservice.Description,
		&i.Hservice.Category,
		&i.Hservice.Price,
		&i.Hservice.PriceUnit,
		&i.Hservice.PriceTimespan,
		&i.Hservice.IsOnline,
		&i.Hservice.Url,
		&i.Hservice.Location,
		&i.Hservice.DeliveryTime,
		&i.Hservice.DeliveryTimespan,
		&i.Hservice.TotalPoints,
		&i.Hservice.TotalVotes,
		&i.Hservice.Media,
		&i.Hservice.CreatedAt,
		&i.Hservice.UpdatedAt,
	)
	return i, err
}

const getBookmarksByUserId = `-- name: GetBookmarksByUserId :many
SELECT bookmarks.id, bookmarks.user_id, bookmarks.hservice_id, bookmarks.created_at, hservices.id, hservices.user_id, hservices.title, hservices.slug, hservices.description, hservices.category, hservices.price, hservices.price_unit, hservices.price_timespan, hservices.is_online, hservices.url, hservices.location, hservices.delivery_time, hservices.delivery_timespan, hservices.total_points, hservices.total_votes, hservices.media, hservices.created_at, hservices.updated_at FROM bookmarks
JOIN hservices ON hservices.id = bookmarks.hservice_id
WHERE bookmarks.user_id = $1
ORDER BY bookmarks.created_at DESC
OFFSET $2
LIMIT $3
`

type GetBookmarksByUserIdParams struct {
	UserID string
	Offset int32
	Limit  int32
}

type GetBookmarksByUserIdRow struct {
	Bookmark Bookmark
	Hservice Hservice
}

func (q *Queries) GetBookmarksByUserId(ctx context.Context, arg GetBookmarksByUserIdParams) ([]GetBookmarksByUserIdRow, error) {
	rows, err := q.db.Query(ctx, getBookmarksByUserId, arg.UserID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBookmarksByUserIdRow
	for rows.Next() {
		var i GetBookmarksByUserIdRow
		if err := rows.Scan(
			&i.Bookmark.ID,
			&i.Bookmark.UserID,
			&i.Bookmark.HserviceID,
			&i.Bookmark.CreatedAt,
			&i.Hservice.ID,
			&i.Hservice.UserID,
			&i.Hservice.Title,
			&i.Hservice.Slug,
			&i.Hservice.Description,
			&i.Hservice.Category,
			&i.Hservice.Price,
			&i.Hservice.PriceUnit,
			&i.Hservice.PriceTimespan,
			&i.Hservice.IsOnline,
			&i.Hservice.Url,
			&i.Hservice.Location,
			&i.Hservice.DeliveryTime,
			&i.Hservice.DeliveryTimespan,
			&i.Hservice.TotalPoints,
			&i.Hservice.TotalVotes,
			&i.Hservice.Media,
			&i.Hservice.CreatedAt,
			&i.Hservice.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFavoriteById = `-- name: GetFavoriteById :one
SELECT favorites.id, favorites.user_id, favorites.hservice_id, favorites.created_at, hservices.id, hservices.user_id, hservices.title, hservices.slug, hservices.description, hservices.category, hservices.price, hservices.price_unit, hservices.price_timespan, hservices.is_online, hservices.url, hservices.location, hservices.delivery_time, hservices.delivery_timespan, hservices.total_points, hservices.total_votes, hservices.media, hservices.created_at, hservices.updated_at FROM favorites
JOIN hservices ON hservices.id = favorites.hservice_id
WHERE favorites.id = $1
`

type GetFavoriteByIdRow struct {
	Favorite Favorite
	Hservice Hservice
}

func (q *Queries) GetFavoriteById(ctx context.Context, id pgtype.UUID) (GetFavoriteByIdRow, error) {
	row := q.db.QueryRow(ctx, getFavoriteById, id)
	var i GetFavoriteByIdRow
	err := row.Scan(
		&i.Favorite.ID,
		&i.Favorite.UserID,
		&i.Favorite.HserviceID,
		&i.Favorite.CreatedAt,
		&i.Hservice.ID,
		&i.Hservice.UserID,
		&i.Hservice.Title,
		&i.Hservice.Slug,
		&i.Hservice.Description,
		&i.Hservice.Category,
		&i.Hservice.Price,
		&i.Hservice.PriceUnit,
		&i.Hservice.PriceTimespan,
		&i.Hservice.IsOnline,
		&i.Hservice.Url,
		&i.Hservice.Location,
		&i.Hservice.DeliveryTime,
		&i.Hservice.DeliveryTimespan,
		&i.Hservice.TotalPoints,
		&i.Hservice.TotalVotes,
		&i.Hservice.Media,
		&i.Hservice.CreatedAt,
		&i.Hservice.UpdatedAt,
	)
	return i, err
}

const getFavoriteHServices = `-- name: GetFavoriteHServices :many
SELECT id, user_id, title, slug, description, category, price, price_unit, price_timespan, is_online, url, location, delivery_time, delivery_timespan, total_points, total_votes, media, created_at, updated_at FROM hservices
ORDER BY total_points -- TODO: Replace with total_favorites later
LIMIT 25
`

func (q *Queries) GetFavoriteHServices(ctx context.Context) ([]Hservice, error) {
	rows, err := q.db.Query(ctx, getFavoriteHServices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Hservice
	for rows.Next() {
		var i Hservice
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.Category,
			&i.Price,
			&i.PriceUnit,
			&i.PriceTimespan,
			&i.IsOnline,
			&i.Url,
			&i.Location,
			&i.DeliveryTime,
			&i.DeliveryTimespan,
			&i.TotalPoints,
			&i.TotalVotes,
			&i.Media,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFavoritesByUserId = `-- name: GetFavoritesByUserId :many
SELECT favorites.id, favorites.user_id, favorites.hservice_id, favorites.created_at, hservices.id, hservices.user_id, hservices.title, hservices.slug, hservices.description, hservices.category, hservices.price, hservices.price_unit, hservices.price_timespan, hservices.is_online, hservices.url, hservices.location, hservices.delivery_time, hservices.delivery_timespan, hservices.total_points, hservices.total_votes, hservices.media, hservices.created_at, hservices.updated_at FROM favorites
JOIN hservices ON hservices.id = favorites.hservice_id
WHERE favorites.user_id = $1
ORDER BY favorites.created_at DESC
OFFSET $2
LIMIT $3
`

type GetFavoritesByUserIdParams struct {
	UserID string
	Offset int32
	Limit  int32
}

type GetFavoritesByUserIdRow struct {
	Favorite Favorite
	Hservice Hservice
}

func (q *Queries) GetFavoritesByUserId(ctx context.Context, arg GetFavoritesByUserIdParams) ([]GetFavoritesByUserIdRow, error) {
	rows, err := q.db.Query(ctx, getFavoritesByUserId, arg.UserID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFavoritesByUserIdRow
	for rows.Next() {
		var i GetFavoritesByUserIdRow
		if err := rows.Scan(
			&i.Favorite.ID,
			&i.Favorite.UserID,
			&i.Favorite.HserviceID,
			&i.Favorite.CreatedAt,
			&i.Hservice.ID,
			&i.Hservice.UserID,
			&i.Hservice.Title,
			&i.Hservice.Slug,
			&i.Hservice.Description,
			&i.Hservice.Category,
			&i.Hservice.Price,
			&i.Hservice.PriceUnit,
			&i.Hservice.PriceTimespan,
			&i.Hservice.IsOnline,
			&i.Hservice.Url,
			&i.Hservice.Location,
			&i.Hservice.DeliveryTime,
			&i.Hservice.DeliveryTimespan,
			&i.Hservice.TotalPoints,
			&i.Hservice.TotalVotes,
			&i.Hservice.Media,
			&i.Hservice.CreatedAt,
			&i.Hservice.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFeaturedHServices = `-- name: GetFeaturedHServices :many
SELECT id, user_id, title, slug, description, category, price, price_unit, price_timespan, is_online, url, location, delivery_time, delivery_timespan, total_points, total_votes, media, created_at, updated_at FROM hservices
ORDER BY total_points
LIMIT 25
`

func (q *Queries) GetFeaturedHServices(ctx context.Context) ([]Hservice, error) {
	rows, err := q.db.Query(ctx, getFeaturedHServices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Hservice
	for rows.Next() {
		var i Hservice
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.Category,
			&i.Price,
			&i.PriceUnit,
			&i.PriceTimespan,
			&i.IsOnline,
			&i.Url,
			&i.Location,
			&i.DeliveryTime,
			&i.DeliveryTimespan,
			&i.TotalPoints,
			&i.TotalVotes,
			&i.Media,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHServiceById = `-- name: GetHServiceById :one
SELECT id, user_id, title, slug, description, category, price, price_unit, price_timespan, is_online, url, location, delivery_time, delivery_timespan, total_points, total_votes, media, created_at, updated_at FROM hservices
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetHServiceById(ctx context.Context, id string) (Hservice, error) {
	row := q.db.QueryRow(ctx, getHServiceById, id)
	var i Hservice
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.Category,
		&i.Price,
		&i.PriceUnit,
		&i.PriceTimespan,
		&i.IsOnline,
		&i.Url,
		&i.Location,
		&i.DeliveryTime,
		&i.DeliveryTimespan,
		&i.TotalPoints,
		&i.TotalVotes,
		&i.Media,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMe = `-- name: GetMe :one
SELECT 
  id,
  email,
  username,
  full_name,
  google_id, 
  is_email_verified, 
  is_active, 
  role, 
  gender,
  profile_image,
  last_login, 
  created_at, 
  updated_at 
FROM users
WHERE id = $1 LIMIT 1
`

type GetMeRow struct {
	ID              string
	Email           string
	Username        string
	FullName        string
	GoogleID        pgtype.Text
	IsEmailVerified bool
	IsActive        bool
	Role            string
	Gender          pgtype.Text
	ProfileImage    pgtype.Text
	LastLogin       pgtype.Timestamptz
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
}

func (q *Queries) GetMe(ctx context.Context, id string) (GetMeRow, error) {
	row := q.db.QueryRow(ctx, getMe, id)
	var i GetMeRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.FullName,
		&i.GoogleID,
		&i.IsEmailVerified,
		&i.IsActive,
		&i.Role,
		&i.Gender,
		&i.ProfileImage,
		&i.LastLogin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMyHServices = `-- name: GetMyHServices :many
SELECT id, user_id, title, slug, description, category, price, price_unit, price_timespan, is_online, url, location, delivery_time, delivery_timespan, total_points, total_votes, media, created_at, updated_at FROM hservices
WHERE user_id = $1
ORDER BY created_at DESC
OFFSET $2
LIMIT $3
`

type GetMyHServicesParams struct {
	UserID string
	Offset int32
	Limit  int32
}

func (q *Queries) GetMyHServices(ctx context.Context, arg GetMyHServicesParams) ([]Hservice, error) {
	rows, err := q.db.Query(ctx, getMyHServices, arg.UserID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Hservice
	for rows.Next() {
		var i Hservice
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.Category,
			&i.Price,
			&i.PriceUnit,
			&i.PriceTimespan,
			&i.IsOnline,
			&i.Url,
			&i.Location,
			&i.DeliveryTime,
			&i.DeliveryTimespan,
			&i.TotalPoints,
			&i.TotalVotes,
			&i.Media,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNewHServices = `-- name: GetNewHServices :many
SELECT id, user_id, title, slug, description, category, price, price_unit, price_timespan, is_online, url, location, delivery_time, delivery_timespan, total_points, total_votes, media, created_at, updated_at FROM hservices
ORDER BY created_at
LIMIT 25
`

func (q *Queries) GetNewHServices(ctx context.Context) ([]Hservice, error) {
	rows, err := q.db.Query(ctx, getNewHServices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Hservice
	for rows.Next() {
		var i Hservice
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.Category,
			&i.Price,
			&i.PriceUnit,
			&i.PriceTimespan,
			&i.IsOnline,
			&i.Url,
			&i.Location,
			&i.DeliveryTime,
			&i.DeliveryTimespan,
			&i.TotalPoints,
			&i.TotalVotes,
			&i.Media,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPopularHServices = `-- name: GetPopularHServices :many
SELECT id, user_id, title, slug, description, category, price, price_unit, price_timespan, is_online, url, location, delivery_time, delivery_timespan, total_points, total_votes, media, created_at, updated_at FROM hservices
ORDER BY total_votes
LIMIT 25
`

func (q *Queries) GetPopularHServices(ctx context.Context) ([]Hservice, error) {
	rows, err := q.db.Query(ctx, getPopularHServices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Hservice
	for rows.Next() {
		var i Hservice
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.Category,
			&i.Price,
			&i.PriceUnit,
			&i.PriceTimespan,
			&i.IsOnline,
			&i.Url,
			&i.Location,
			&i.DeliveryTime,
			&i.DeliveryTimespan,
			&i.TotalPoints,
			&i.TotalVotes,
			&i.Media,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, username, full_name, password_hash, google_id, is_email_verified, is_active, role, password_reset_token, password_reset_expires, login_attempts, lockout_until, gender, profile_image, last_login, created_at, updated_at FROM users
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.FullName,
		&i.PasswordHash,
		&i.GoogleID,
		&i.IsEmailVerified,
		&i.IsActive,
		&i.Role,
		&i.PasswordResetToken,
		&i.PasswordResetExpires,
		&i.LoginAttempts,
		&i.LockoutUntil,
		&i.Gender,
		&i.ProfileImage,
		&i.LastLogin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByGoogleId = `-- name: GetUserByGoogleId :one
SELECT id, email, username, full_name, password_hash, google_id, is_email_verified, is_active, role, password_reset_token, password_reset_expires, login_attempts, lockout_until, gender, profile_image, last_login, created_at, updated_at FROM users
WHERE google_id = $1 LIMIT 1
`

func (q *Queries) GetUserByGoogleId(ctx context.Context, googleID pgtype.Text) (User, error) {
	row := q.db.QueryRow(ctx, getUserByGoogleId, googleID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.FullName,
		&i.PasswordHash,
		&i.GoogleID,
		&i.IsEmailVerified,
		&i.IsActive,
		&i.Role,
		&i.PasswordResetToken,
		&i.PasswordResetExpires,
		&i.LoginAttempts,
		&i.LockoutUntil,
		&i.Gender,
		&i.ProfileImage,
		&i.LastLogin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT id, email, username, full_name, password_hash, google_id, is_email_verified, is_active, role, password_reset_token, password_reset_expires, login_attempts, lockout_until, gender, profile_image, last_login, created_at, updated_at FROM users
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserById(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.FullName,
		&i.PasswordHash,
		&i.GoogleID,
		&i.IsEmailVerified,
		&i.IsActive,
		&i.Role,
		&i.PasswordResetToken,
		&i.PasswordResetExpires,
		&i.LoginAttempts,
		&i.LockoutUntil,
		&i.Gender,
		&i.ProfileImage,
		&i.LastLogin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, email, username, full_name, password_hash, google_id, is_email_verified, is_active, role, password_reset_token, password_reset_expires, login_attempts, lockout_until, gender, profile_image, last_login, created_at, updated_at FROM users
WHERE username = $1 LIMIT 1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.FullName,
		&i.PasswordHash,
		&i.GoogleID,
		&i.IsEmailVerified,
		&i.IsActive,
		&i.Role,
		&i.PasswordResetToken,
		&i.PasswordResetExpires,
		&i.LoginAttempts,
		&i.LockoutUntil,
		&i.Gender,
		&i.ProfileImage,
		&i.LastLogin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserProfileByUsername = `-- name: GetUserProfileByUsername :one
SELECT
  id,
  username,
  full_name,
  gender,
  profile_image,
  created_at
FROM users
WHERE username = $1
LIMIT 1
`

type GetUserProfileByUsernameRow struct {
	ID           string
	Username     string
	FullName     string
	Gender       pgtype.Text
	ProfileImage pgtype.Text
	CreatedAt    pgtype.Timestamptz
}

func (q *Queries) GetUserProfileByUsername(ctx context.Context, username string) (GetUserProfileByUsernameRow, error) {
	row := q.db.QueryRow(ctx, getUserProfileByUsername, username)
	var i GetUserProfileByUsernameRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.FullName,
		&i.Gender,
		&i.ProfileImage,
		&i.CreatedAt,
	)
	return i, err
}

const isBookmarked = `-- name: IsBookmarked :one
SELECT id FROM bookmarks
WHERE id = $1 AND user_id = $2
`

type IsBookmarkedParams struct {
	ID     pgtype.UUID
	UserID string
}

func (q *Queries) IsBookmarked(ctx context.Context, arg IsBookmarkedParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, isBookmarked, arg.ID, arg.UserID)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const isFavorite = `-- name: IsFavorite :one
SELECT id FROM favorites
WHERE id = $1 AND user_id = $2
`

type IsFavoriteParams struct {
	ID     pgtype.UUID
	UserID string
}

func (q *Queries) IsFavorite(ctx context.Context, arg IsFavoriteParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, isFavorite, arg.ID, arg.UserID)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const listHServices = `-- name: ListHServices :many
SELECT id, user_id, title, slug, description, category, price, price_unit, price_timespan, is_online, url, location, delivery_time, delivery_timespan, total_points, total_votes, media, created_at, updated_at FROM hservices
ORDER BY created_at ASC
OFFSET $1
LIMIT $2
`

type ListHServicesParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) ListHServices(ctx context.Context, arg ListHServicesParams) ([]Hservice, error) {
	rows, err := q.db.Query(ctx, listHServices, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Hservice
	for rows.Next() {
		var i Hservice
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.Category,
			&i.Price,
			&i.PriceUnit,
			&i.PriceTimespan,
			&i.IsOnline,
			&i.Url,
			&i.Location,
			&i.DeliveryTime,
			&i.DeliveryTimespan,
			&i.TotalPoints,
			&i.TotalVotes,
			&i.Media,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserGoogleId = `-- name: UpdateUserGoogleId :exec
UPDATE users
  SET google_id = $2
WHERE id = $1
`

type UpdateUserGoogleIdParams struct {
	ID       string
	GoogleID pgtype.Text
}

func (q *Queries) UpdateUserGoogleId(ctx context.Context, arg UpdateUserGoogleIdParams) error {
	_, err := q.db.Exec(ctx, updateUserGoogleId, arg.ID, arg.GoogleID)
	return err
}
