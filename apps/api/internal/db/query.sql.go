// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countMyHServices = `-- name: CountMyHServices :one
SELECT COUNT(*) FROM hservices
WHERE user_id = $1
`

func (q *Queries) CountMyHServices(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRow(ctx, countMyHServices, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCountry = `-- name: CreateCountry :one
INSERT INTO countries (
  id,
  name,
  iso2,
  numeric_code,
  phone_code,
  capital,
  currency,
  currency_name,
  currency_symbol,
  tld,
  native,
  region,
  subregion,
  timezones,
  latitude,
  longitude
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10,
  $11,
  $12,
  $13,
  $14,
  $15,
  $16
)
RETURNING id, name, iso2, numeric_code, phone_code, capital, currency, currency_name, currency_symbol, tld, native, region, subregion, timezones, latitude, longitude
`

type CreateCountryParams struct {
	ID             int32
	Name           string
	Iso2           string
	NumericCode    string
	PhoneCode      string
	Capital        string
	Currency       string
	CurrencyName   string
	CurrencySymbol string
	Tld            string
	Native         string
	Region         string
	Subregion      string
	Timezones      string
	Latitude       float64
	Longitude      float64
}

func (q *Queries) CreateCountry(ctx context.Context, arg CreateCountryParams) (Country, error) {
	row := q.db.QueryRow(ctx, createCountry,
		arg.ID,
		arg.Name,
		arg.Iso2,
		arg.NumericCode,
		arg.PhoneCode,
		arg.Capital,
		arg.Currency,
		arg.CurrencyName,
		arg.CurrencySymbol,
		arg.Tld,
		arg.Native,
		arg.Region,
		arg.Subregion,
		arg.Timezones,
		arg.Latitude,
		arg.Longitude,
	)
	var i Country
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Iso2,
		&i.NumericCode,
		&i.PhoneCode,
		&i.Capital,
		&i.Currency,
		&i.CurrencyName,
		&i.CurrencySymbol,
		&i.Tld,
		&i.Native,
		&i.Region,
		&i.Subregion,
		&i.Timezones,
		&i.Latitude,
		&i.Longitude,
	)
	return i, err
}

const createHService = `-- name: CreateHService :one
INSERT INTO hservices (
  id,
  user_id,
  title,
  slug,
  description,
  category,
  price,
  price_unit,
  price_timespan,
  is_online,
  url,
  location,
  delivery_time,
  delivery_timespan,
  total_points,
  total_votes,
  media,
  created_at,
  updated_at
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10,
  $11,
  $12,
  $13,
  $14,
  $15,
  $16,
  $17,
  $18,
  $19
)
RETURNING id, user_id, title, slug, description, category, price, price_unit, price_timespan, is_online, url, location, delivery_time, delivery_timespan, total_points, total_votes, media, created_at, updated_at
`

type CreateHServiceParams struct {
	ID               string
	UserID           string
	Title            string
	Slug             string
	Description      string
	Category         int32
	Price            float64
	PriceUnit        Priceunit
	PriceTimespan    Worktimespan
	IsOnline         bool
	Url              pgtype.Text
	Location         string
	DeliveryTime     int32
	DeliveryTimespan Worktimespan
	TotalPoints      int64
	TotalVotes       int32
	Media            []byte
	CreatedAt        pgtype.Timestamptz
	UpdatedAt        pgtype.Timestamptz
}

func (q *Queries) CreateHService(ctx context.Context, arg CreateHServiceParams) (Hservice, error) {
	row := q.db.QueryRow(ctx, createHService,
		arg.ID,
		arg.UserID,
		arg.Title,
		arg.Slug,
		arg.Description,
		arg.Category,
		arg.Price,
		arg.PriceUnit,
		arg.PriceTimespan,
		arg.IsOnline,
		arg.Url,
		arg.Location,
		arg.DeliveryTime,
		arg.DeliveryTimespan,
		arg.TotalPoints,
		arg.TotalVotes,
		arg.Media,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Hservice
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.Category,
		&i.Price,
		&i.PriceUnit,
		&i.PriceTimespan,
		&i.IsOnline,
		&i.Url,
		&i.Location,
		&i.DeliveryTime,
		&i.DeliveryTimespan,
		&i.TotalPoints,
		&i.TotalVotes,
		&i.Media,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createState = `-- name: CreateState :one
INSERT INTO states (
  id,
  name,
  country_id,
  country_code,
  country_name,
  state_code,
  type,
  latitude,
  longitude
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9
)
RETURNING id, name, country_id, country_code, country_name, state_code, type, latitude, longitude
`

type CreateStateParams struct {
	ID          int32
	Name        string
	CountryID   int32
	CountryCode string
	CountryName string
	StateCode   string
	Type        pgtype.Text
	Latitude    float64
	Longitude   float64
}

func (q *Queries) CreateState(ctx context.Context, arg CreateStateParams) (State, error) {
	row := q.db.QueryRow(ctx, createState,
		arg.ID,
		arg.Name,
		arg.CountryID,
		arg.CountryCode,
		arg.CountryName,
		arg.StateCode,
		arg.Type,
		arg.Latitude,
		arg.Longitude,
	)
	var i State
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CountryID,
		&i.CountryCode,
		&i.CountryName,
		&i.StateCode,
		&i.Type,
		&i.Latitude,
		&i.Longitude,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
  id,
  email,
  username,
  full_name,
  password_hash,
  google_id,
  is_email_verified,
  profile_image
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8
)
RETURNING id, email, username, full_name, password_hash, google_id, is_email_verified, is_active, role, password_reset_token, password_reset_expires, login_attempts, lockout_until, gender, profile_image, last_login, created_at, updated_at
`

type CreateUserParams struct {
	ID              string
	Email           string
	Username        string
	FullName        string
	PasswordHash    pgtype.Text
	GoogleID        pgtype.Text
	IsEmailVerified bool
	ProfileImage    pgtype.Text
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.ID,
		arg.Email,
		arg.Username,
		arg.FullName,
		arg.PasswordHash,
		arg.GoogleID,
		arg.IsEmailVerified,
		arg.ProfileImage,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.FullName,
		&i.PasswordHash,
		&i.GoogleID,
		&i.IsEmailVerified,
		&i.IsActive,
		&i.Role,
		&i.PasswordResetToken,
		&i.PasswordResetExpires,
		&i.LoginAttempts,
		&i.LockoutUntil,
		&i.Gender,
		&i.ProfileImage,
		&i.LastLogin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getHServiceById = `-- name: GetHServiceById :one
SELECT id, user_id, title, slug, description, category, price, price_unit, price_timespan, is_online, url, location, delivery_time, delivery_timespan, total_points, total_votes, media, created_at, updated_at FROM hservices
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetHServiceById(ctx context.Context, id string) (Hservice, error) {
	row := q.db.QueryRow(ctx, getHServiceById, id)
	var i Hservice
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.Category,
		&i.Price,
		&i.PriceUnit,
		&i.PriceTimespan,
		&i.IsOnline,
		&i.Url,
		&i.Location,
		&i.DeliveryTime,
		&i.DeliveryTimespan,
		&i.TotalPoints,
		&i.TotalVotes,
		&i.Media,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMe = `-- name: GetMe :one
SELECT 
  id,
  email,
  username,
  full_name,
  google_id, 
  is_email_verified, 
  is_active, 
  role, 
  gender,
  profile_image,
  last_login, 
  created_at, 
  updated_at 
FROM users
WHERE id = $1 LIMIT 1
`

type GetMeRow struct {
	ID              string
	Email           string
	Username        string
	FullName        string
	GoogleID        pgtype.Text
	IsEmailVerified bool
	IsActive        bool
	Role            string
	Gender          pgtype.Text
	ProfileImage    pgtype.Text
	LastLogin       pgtype.Timestamptz
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
}

func (q *Queries) GetMe(ctx context.Context, id string) (GetMeRow, error) {
	row := q.db.QueryRow(ctx, getMe, id)
	var i GetMeRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.FullName,
		&i.GoogleID,
		&i.IsEmailVerified,
		&i.IsActive,
		&i.Role,
		&i.Gender,
		&i.ProfileImage,
		&i.LastLogin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMyHServices = `-- name: GetMyHServices :many
SELECT id, user_id, title, slug, description, category, price, price_unit, price_timespan, is_online, url, location, delivery_time, delivery_timespan, total_points, total_votes, media, created_at, updated_at FROM hservices
WHERE user_id = $1
ORDER BY created_at DESC
OFFSET $2
LIMIT $3
`

type GetMyHServicesParams struct {
	UserID string
	Offset int32
	Limit  int32
}

func (q *Queries) GetMyHServices(ctx context.Context, arg GetMyHServicesParams) ([]Hservice, error) {
	rows, err := q.db.Query(ctx, getMyHServices, arg.UserID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Hservice
	for rows.Next() {
		var i Hservice
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.Category,
			&i.Price,
			&i.PriceUnit,
			&i.PriceTimespan,
			&i.IsOnline,
			&i.Url,
			&i.Location,
			&i.DeliveryTime,
			&i.DeliveryTimespan,
			&i.TotalPoints,
			&i.TotalVotes,
			&i.Media,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, username, full_name, password_hash, google_id, is_email_verified, is_active, role, password_reset_token, password_reset_expires, login_attempts, lockout_until, gender, profile_image, last_login, created_at, updated_at FROM users
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.FullName,
		&i.PasswordHash,
		&i.GoogleID,
		&i.IsEmailVerified,
		&i.IsActive,
		&i.Role,
		&i.PasswordResetToken,
		&i.PasswordResetExpires,
		&i.LoginAttempts,
		&i.LockoutUntil,
		&i.Gender,
		&i.ProfileImage,
		&i.LastLogin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByGoogleId = `-- name: GetUserByGoogleId :one
SELECT id, email, username, full_name, password_hash, google_id, is_email_verified, is_active, role, password_reset_token, password_reset_expires, login_attempts, lockout_until, gender, profile_image, last_login, created_at, updated_at FROM users
WHERE google_id = $1 LIMIT 1
`

func (q *Queries) GetUserByGoogleId(ctx context.Context, googleID pgtype.Text) (User, error) {
	row := q.db.QueryRow(ctx, getUserByGoogleId, googleID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.FullName,
		&i.PasswordHash,
		&i.GoogleID,
		&i.IsEmailVerified,
		&i.IsActive,
		&i.Role,
		&i.PasswordResetToken,
		&i.PasswordResetExpires,
		&i.LoginAttempts,
		&i.LockoutUntil,
		&i.Gender,
		&i.ProfileImage,
		&i.LastLogin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT id, email, username, full_name, password_hash, google_id, is_email_verified, is_active, role, password_reset_token, password_reset_expires, login_attempts, lockout_until, gender, profile_image, last_login, created_at, updated_at FROM users
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserById(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.FullName,
		&i.PasswordHash,
		&i.GoogleID,
		&i.IsEmailVerified,
		&i.IsActive,
		&i.Role,
		&i.PasswordResetToken,
		&i.PasswordResetExpires,
		&i.LoginAttempts,
		&i.LockoutUntil,
		&i.Gender,
		&i.ProfileImage,
		&i.LastLogin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, email, username, full_name, password_hash, google_id, is_email_verified, is_active, role, password_reset_token, password_reset_expires, login_attempts, lockout_until, gender, profile_image, last_login, created_at, updated_at FROM users
WHERE username = $1 LIMIT 1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.FullName,
		&i.PasswordHash,
		&i.GoogleID,
		&i.IsEmailVerified,
		&i.IsActive,
		&i.Role,
		&i.PasswordResetToken,
		&i.PasswordResetExpires,
		&i.LoginAttempts,
		&i.LockoutUntil,
		&i.Gender,
		&i.ProfileImage,
		&i.LastLogin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserGoogleId = `-- name: UpdateUserGoogleId :exec
UPDATE users
  SET google_id = $2
WHERE id = $1
`

type UpdateUserGoogleIdParams struct {
	ID       string
	GoogleID pgtype.Text
}

func (q *Queries) UpdateUserGoogleId(ctx context.Context, arg UpdateUserGoogleIdParams) error {
	_, err := q.db.Exec(ctx, updateUserGoogleId, arg.ID, arg.GoogleID)
	return err
}
